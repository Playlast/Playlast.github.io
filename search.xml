<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[SCOI2009] 生日礼物]]></title>
    <url>%2F%2FSCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[题目链接 [SCOI2009]生日礼物 题意简述有一条纸带上挂着 $n \ (n &lt;= 1000000)$ 个小球，小球有 $k \ (k &lt;= 60)$ 种颜色。 找出一个最小的包含所有颜色的区间。 思路暴力想不到啊2333。时间复杂度： $O(?)$ 。 单调队列使一个队列中一直保持有所有颜色，不断向右移动若末尾小球的颜色出现次数 $ &gt; 1$ ，将其弹出，直到末尾小球的颜色出现次数 $ = 1$ 。时间复杂度： $O(n)$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e6 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n, k;#define pii std::pair&lt;int, int&gt;#define mp std::make_pairpii point[kmax_num];int col[61];std::deque&lt;pii&gt; queue;inline bool Check() &#123; For(i,1,k) if(!col[i]) return 1; return 0;&#125;int main() &#123; std::cin &gt;&gt; n &gt;&gt; k; REG int sum, pos, cnt = -1; For(i,1,k) &#123; std::cin &gt;&gt; sum; FOR(h,0,sum) &#123; std::cin &gt;&gt; pos; point[++cnt] = mp(pos, i); &#125; &#125; std::sort(point, point + n); cnt = 0; while(Check()) &#123; queue.push_front(point[cnt]); ++col[point[cnt].second]; ++cnt; &#125; REG int ans = 0x7fffffff; while(cnt &lt; n) &#123; ans = std::min(ans, queue.front().first - queue.back().first); queue.push_front(point[cnt]); ++col[point[cnt].second]; while(col[queue.back().second] &gt; 1) --col[queue.back().second], queue.pop_back(); ++cnt; &#125; ans = std::min(ans, queue.front().first - queue.back().first); printf("%d\n", ans); return 0;&#125; 杂项 这里用了 $std::pair$ 实现，$std::pair$ 大法好！]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>双端队列</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2007] 理想的正方形]]></title>
    <url>%2F%2FHAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目链接[HAOI2007]理想的正方形 题意简述有一个 $n * m \ (n, \ m &lt;= 1000)$ 的整数组成的矩阵。 找出一个 $k * k \ (k &lt;= 100)$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 思路暴力首先考虑暴力，也就是暴力枚举起点，暴力求最大值和最小值。时间复杂度： $O(n^{4})$ 。 二维RMQ看到要求最大值与最小值，就想起RMQ。常规二维RMQ空间复杂度太大，需要 $(n^{2}2logk)$ 的空间， 开不下啊2333。但是这道题很特殊，它的查询的是正方形，因此并不需要二维倍增。所以就砍下了一维。下面会给出常规二维RMQ与特殊二维RMQ。空间复杂度： $O(n^{2}logk)$ 。时间复杂度： $O(n^{2}logk)$ 。 DP据说可以用单调队列维护。我太蒻了，并不会。。。。。 代码二维RMQ123456789101112131415161718192021222324252627282930313233343536const int kmax_num = 1e3 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n, m, k;int rmq_max[kmax_num][kmax_num][11][11], rmq_min[kmax_num][kmax_num][11][11];inline void Init() &#123; for(REG int i = 1; (1 &lt;&lt; i) &lt;= n; ++i) for(REG int h = 1; (1 &lt;&lt; h) &lt;= m; ++h) &#123; if(!i &amp;&amp; !h) continue; else &#123; for(REG int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; ++row) for(REG int col = 1; col + (1 &lt;&lt; h) - 1 &lt;= m; ++col) if(i) rmq_max[row][col][i][h] = std::max(rmq_max[row][col][i - 1][h], rmq_max[row + (1 &lt;&lt; (i - 1))][col][i - 1][h]), rmq_min[row][col][i][h] = std::min(rmq_min[row][col][i - 1][h], rmq_min[row + (1 &lt;&lt; (i - 1))][col][i - 1][h]); else rmq_max[row][col][i][h] = std::max(rmq_max[row][col][i][h - 1], rmq_max[row][col + (1 &lt;&lt; (h - 1))][i][h - 1]), rmq_min[row][col][i][h] = std::min(rmq_min[row][col][i][h - 1], rmq_min[row][col + (1 &lt;&lt; (h - 1))][i][h - 1]); &#125; &#125; return ;&#125;inline int Query(REG int ax, REG int ay, REG int bx, REG int by) &#123; REG int t1 = (int) log2(bx - ax + 1); REG int t2 = (int) log2(by - ay + 1); REG int m1 = rmq_max[ax][ay][t1][t2]; REG int m2 = rmq_max[bx - (1 &lt;&lt; t1) + 1][ay][t1][t2]; REG int m3 = rmq_max[ax][by - (1 &lt;&lt; t2) + 1][t1][t2]; REG int m4 = rmq_max[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t2) + 1][t1][t2]; REG int m5 = rmq_min[ax][ay][t1][t2]; REG int m6 = rmq_min[bx - (1 &lt;&lt; t1) + 1][ay][t1][t2]; REG int m7 = rmq_min[ax][by - (1 &lt;&lt; t2) + 1][t1][t2]; REG int m8 = rmq_min[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t2) + 1][t1][t2]; return std::max(std::max(m1, m2), std::max(m3, m4)) - std::min(std::min(m5, m6), std::min(m7, m8));&#125; 二维RMQ-UDP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//============================================================================// Name : Program3.cpp// Author : PN// Version : V214.7483647// Copyright : CCCP// Description : C++, Ansi-style//============================================================================#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e3 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n, m, k;int rmq_max[kmax_num][kmax_num][11], rmq_min[kmax_num][kmax_num][11];inline void Init() &#123; for(REG int i = 1; (1 &lt;&lt; i) &lt;= k; ++i) &#123; for(REG int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; ++row) for(REG int col = 1; col + (1 &lt;&lt; i) - 1 &lt;= m; ++col) rmq_max[row][col][i] = std::max(std::max(rmq_max[row][col][i - 1], rmq_max[row + (1 &lt;&lt; (i - 1))][col][i - 1]), std::max(rmq_max[row][col + (1 &lt;&lt; (i - 1))][i - 1], rmq_max[row + (1 &lt;&lt; (i - 1))][col + (1 &lt;&lt; (i - 1))][i - 1])), rmq_min[row][col][i] = std::min(std::min(rmq_min[row][col][i - 1], rmq_min[row + (1 &lt;&lt; (i - 1))][col][i - 1]), std::min(rmq_min[row][col + (1 &lt;&lt; (i - 1))][i - 1], rmq_min[row + (1 &lt;&lt; (i - 1))][col + (1 &lt;&lt; (i - 1))][i - 1])); &#125; return ;&#125;inline int Query(REG int ax, REG int ay, REG int bx, REG int by) &#123; REG int t1 = (int) log2(bx - ax + 1);// REG int t1 = (int) log2(k + 1); REG int m1 = rmq_max[ax][ay][t1]; REG int m2 = rmq_max[bx - (1 &lt;&lt; t1) + 1][ay][t1]; REG int m3 = rmq_max[ax][by - (1 &lt;&lt; t1) + 1][t1]; REG int m4 = rmq_max[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t1) + 1][t1]; REG int m5 = rmq_min[ax][ay][t1]; REG int m6 = rmq_min[bx - (1 &lt;&lt; t1) + 1][ay][t1]; REG int m7 = rmq_min[ax][by - (1 &lt;&lt; t1) + 1][t1]; REG int m8 = rmq_min[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t1) + 1][t1]; return std::max(std::max(m1, m2), std::max(m3, m4)) - std::min(std::min(m5, m6), std::min(m7, m8));&#125;int main() &#123; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; For(i,1,n) For(h,1,m) std::cin &gt;&gt; rmq_max[i][h][0], rmq_min[i][h][0] = rmq_max[i][h][0]; Init(); REG int ans = 0x7fffffff; for(REG int i = 1; i + k - 1 &lt;= n; ++i) for(REG int h = 1; h + k - 1 &lt;= m; ++h) ans = std::min(ans, Query(i, h, i + k - 1, h + k - 1)); printf("%d\n", ans); return 0;&#125; 杂项 这里的二维RMQ要是 $(n \ == \ 0 \ || \ m \ == \ 0)$ 就是一个一维RMQ。]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二维RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003] 消防局的设立]]></title>
    <url>%2F%2FHNOI2003-%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[题目链接[HNOI2003]消防局的设立 题意简述给出一棵节点数为 $n \ (n &lt;= 1000)$ 的树，每条边长度为 $1$ 。 一次操作作用于一个节点，并将距此节点 $dist &lt;= 2$ 的节点染色，求将整棵树染上颜色的最小次数。 思路暴力首先考虑暴力，也就是暴力枚举。时间复杂度： $O(n^{2})$ 。由于数据太水，暴力随便打吧。 贪心一开始我是想到节点要尽可能向中间靠拢，染色少浪费，可是并不容易做到。从上向下？没思路。（一开始没想到）但从下向上就好想多了。记录 $BFS$ 序，也就是深度。从最底层找起，当它没被染色时，给它的爷爷（雾）染色 $(depth &lt;= 2)$ ，这样能保证高效利用。为什么不用 $DFS$ 记录呢？ 效率不及 $BFS$ 。 记录深度还要排序，而 $BFS$ 记录只需要一个栈。时间复杂度： $O(n)$ （大概吧）。 树形DP我太蒻了，并不会。。。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//============================================================================// Name : Program3.cpp// Author : PN// Version : V214.7483647// Copyright : CCCP// Description : C++, Ansi-style//============================================================================#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 2e3 + 10, kmax_int = 2147483647, kmod = 1e9+7;#define pii std::pair&lt;int, int&gt;#define ppiii std::pair&lt;pii, int&gt;#define mp std::make_pairint n;pii e[kmax_num];int head[kmax_num], cnt;int f[kmax_num];inline void AddEdge(REG int u, REG int v) &#123; e[++cnt] = mp(v, head[u]); head[u] = cnt; e[++cnt] = mp(u, head[v]); head[v] = cnt; return ;&#125;std::queue&lt;int&gt; q;std::stack&lt;int&gt; s;inline void BFS() &#123; q.push(1), s.push(1); while(!q.empty()) &#123; REG int u = q.front(); q.pop(); for(REG int i = head[u]; i; i = e[i].second) if(e[i].first != f[u]) q.push(e[i].first), s.push(e[i].first); &#125; return ;&#125;bool vis[kmax_num];std::queue&lt;pii&gt; mq;inline void Mark(REG int u, REG int dep) &#123; mq.push(mp(u, 0)); while(!mq.empty()) &#123; REG pii u = mq.front(); mq.pop(); for(REG int i = head[u.first]; i; i = e[i].second) &#123; vis[e[i].first] = 1; if(u.second &lt; 1) mq.push(mp(e[i].first, u.second + 1)); &#125; &#125; return ;&#125;int main() &#123; std::cin &gt;&gt; n; FOR(i,1,n) std::cin &gt;&gt; f[i + 1], AddEdge(f[i + 1], i + 1); BFS(); REG int ans = 0; while(!s.empty()) &#123; REG int u = s.top(); s.pop(); if(!vis[u]) vis[u] = true, Mark(f[f[u]], 0), ++ans; &#125; printf("%d\n", ans); return 0;&#125; 杂项 这里用了 $std::pair$ 实现，$std::pair$ 大法好！]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF962D Merge Equals]]></title>
    <url>%2F%2FCF962D-Merge-Equals%2F</url>
    <content type="text"><![CDATA[题目链接CF962D Merge Equals 题意简述给出一个长度为 $n \ (2&lt;= n &lt;= 150000)$ 的数组， 数组内元素 $a_{i} \ (1 &lt;= a_{i} &lt;= 1e9)$ 。 每次操作将数组内两个相同的最小的最靠左的元素取出，并将左边的合并到右边，直到不能操作为止，输出最后的数组。 例：$[1, 1, 3, 1, 1]~\rightarrow~[2, 3, 1, 1]~\rightarrow~[2, 3, 2]~\rightarrow~[3, 4]$ 思路暴力首先考虑暴力，也就是暴力查找。时间复杂度： $O(n^{2})$ 。 正解正解应该挺容易想到的，用堆维护数值和位置，每次取出两个，不相同就删了第一个，否则合并。时间复杂度： $O(n \ log(n))$ 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e6 + 10, kmax_int = 2147483647, kmod = 1e9+7;#define pli std::pair&lt;long long, int&gt;#define mp std::make_pairint n;long long f[kmax_num];std::set&lt;pli&gt; set;int main() &#123; std::cin &gt;&gt; n; FOR(i,0,n) std::cin &gt;&gt; f[i], set.insert(mp(f[i], i)); REG pli t1, t2; while(!set.empty()) &#123; t1 = *set.begin(), t2 = *(++set.begin()); if(t1.first != t2.first) &#123; set.erase(set.begin()); &#125; else &#123; set.insert(mp(t1.first &lt;&lt; 1, t2.second)); f[t1.second] = 0; f[t2.second] = t1.first &lt;&lt; 1; set.erase(set.begin()); set.erase(set.begin()); &#125; &#125; REG int ans = 0; FOR(i,0,n) if(f[i]) ++ans; printf("%d\n", ans); FOR(i,0,n) if(f[i]) printf("%lld ", f[i]); printf("\n"); return 0;&#125; 杂项 这里用 $std::set$ 实现，$std::set$ 大法好！ 这里还用了 $std::pair$ 实现，$std::pair$ 大法好！ 这道题在洛谷上居然是紫题！！还不去水一发吗2333]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
</search>
