<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[SCOI2008] 配对]]></title>
    <url>%2F%2FSCOI2008-%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目链接[SCOI2008]配对 题意简述有一个 $n \ (n &lt;= 100000)$ 对整数需要配对。 所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。 思路暴力DP？一开始我是一头雾水，看了 $dalao$ 博客才知道要分类讨论。由于我 $markdown$ 技术巨烂，将就看看吧。 与距离为0的数匹配 a_{1} \\ | \\ b_{1} 与距离为1的数匹配 \ \ \ \ \ a_{1} \quad a_{2} \\ \quad \backslash \\ \ \ \ \ \ b_{1} \quad b_{2} \\ + a_{2} ~\rightarrow b_{2} 与距离为2的数匹配 a_{1} \quad a_{2} \quad a_{3} \\ \backslash \quad \ \backslash \\ b_{1} \quad b_{2} \quad b_{3} \\ + a_{3} ~\rightarrow b_{1} \\ a_{1} \quad a_{2} \quad a_{3} \\ / \quad \ / \\ b_{1} \quad b_{2} \quad b_{3} \\ + a_{1} ~\rightarrow b_{3} \\ a_{1} \quad a_{2} \quad a_{3} \\ | \\ b_{1} \quad b_{2} \quad b_{3} \\ + a_{1} ~\rightarrow b_{3} \\ + a_{3} ~\rightarrow b_{1} \\ 与距离为3的数匹配可以发现最优情况一定是两个与距离为1的数匹配。 a_{1} \quad a_{2} \quad a_{3} \quad a_{4} \\ \backslash \quad \ \ \ \ \ \ \ \ \ \ \backslash \\ b_{1} \quad b_{2} \quad b_{3} \quad b_{4} \\ + a_{2} ~\rightarrow b_{1} \\ + a_{4} ~\rightarrow b_{3} \\ 分类讨论所以只有 $5$ 种情况，慢慢递推处理就好。空间复杂度： $O(n)$ 。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e5 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n;int n1[kmax_num], n2[kmax_num];long long f[kmax_num];int main() &#123; std::cin &gt;&gt; n; For(i,1,n) std::cin &gt;&gt; n1[i] &gt;&gt; n2[i]; std::sort(n1 + 1, n1 + n + 1), std::sort(n2 + 1, n2 + n + 1); For(i,1,n) &#123; f[i] = f[i - 1] + (n1[i] == n2[i] ? 0x3f3f3f3f : abs(n1[i] - n2[i])); if(i &gt;= 2 &amp;&amp; n1[i - 1] != n2[i] &amp;&amp; n1[i] != n2[i - 1]) f[i] = std::min(f[i], f[i - 2] + abs(n1[i - 1] - n2[i]) + abs(n1[i] - n2[i - 1])); if(i &gt;= 3 &amp;&amp; n1[i - 2] != n2[i - 1] &amp;&amp; n1[i - 1] != n2[i] &amp;&amp; n1[i] != n2[i - 2]) f[i] = std::min(f[i], f[i - 3] + abs(n1[i - 2] - n2[i - 1]) + abs(n1[i - 1] - n2[i]) + abs(n1[i] - n2[i - 2])); if(i &gt;= 3 &amp;&amp; n1[i - 2] != n2[i] &amp;&amp; n1[i - 1] != n2[i - 2] &amp;&amp; n1[i] != n2[i - 1]) f[i] = std::min(f[i], f[i - 3] + abs(n1[i - 2] - n2[i]) + abs(n1[i - 1] - n2[i - 2]) + abs(n1[i] - n2[i - 1])); if(i &gt;= 3 &amp;&amp; n1[i - 2] != n2[i] &amp;&amp; n1[i - 1] != n2[i - 1] &amp;&amp; n1[i] != n2[i - 2]) f[i] = std::min(f[i], f[i - 3] + abs(n1[i - 2] - n2[i]) + abs(n1[i - 1] - n2[i - 1]) + abs(n1[i] - n2[i - 2])); &#125; printf("%lld\n", f[n]); return 0;&#125; 杂项 记得要开 $long long$ 。 这份代码十分暴力。]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2009] 逆序对数列]]></title>
    <url>%2F%2FHAOI2009-%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目链接[HAOI2009]逆序对数列 题意简述求 $n \ (n &lt;= 1000)$ 的全排列中逆序对个数为 $k \ (k &lt;= 1000)$ 的数目。 思路暴力暴力枚举全排列 (std::next \_ permutation) ，暴力统计。时间复杂度： $O(!n * n^{2})$ 。预期得分： $(30)$。 暴力-UDP暴力枚举全排列 (std::next \_ permutation) ，树状数组求逆序对。时间复杂度： $O(!n * nlogn)$ 。预期得分： $(30)$。 DP新来的数是坠大的，所以把它插入到第 $pos$ 个位置会产生 $(n - pos - 1)$ 个逆序对。状态转移方程： \begin {equation*} f[n][k] = \sum _ {h=std::max(0, k - n + 1)}^kf[n - 1][h] \end {equation*}时间复杂度： $O(n^{3})$ 。预期得分： $(60)$。 DP-UDP可以发现每次转移都是一段区间，考虑用前缀和维护。时间复杂度： $O(n^{2})$ 。预期得分： $(100)$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e3 + 10, kmax_int = 2147483647, kmod = 1e4;int n, m;int f[kmax_num][kmax_num];inline void Mod(REG int&amp; num) &#123; while(num &lt; 0) num += kmod; while(num &gt;= kmod) num -= kmod; return ;&#125;int main() &#123; std::cin &gt;&gt; n &gt;&gt; m; f[2][0] = f[2][1] = 1; s[2][0] = 1, s[2][1] = 2, s[2][2] = 2, s[2][3] = 2; REG int sum; For(i,3,n) &#123; sum = 0; For(h,0,m) &#123; sum += f[i - 1][h]; if(h - i &gt;= 0) sum -= f[i - 1][h - i]; Mod(sum); f[i][h] = sum; &#125; &#125; printf("%d\n", f[n][m]); return 0;&#125; 杂项 一开始没用前缀和 $TLE$ 还 $debug$ 了好久。 原来的前缀和计算是用数组乱搞的，后来重构了。]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2007] 理想的正方形]]></title>
    <url>%2F%2FHAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目链接[HAOI2007]理想的正方形 题意简述有一个 $n * m \ (n, \ m &lt;= 1000)$ 的整数组成的矩阵。 找出一个 $k * k \ (k &lt;= 100)$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 思路暴力首先考虑暴力，也就是暴力枚举起点，暴力求最大值和最小值。时间复杂度： $O(n^{4})$ 。 二维RMQ看到要求最大值与最小值，就想起RMQ。常规二维RMQ空间复杂度太大，需要 $(n^{2}2logk)$ 的空间， 开不下啊2333。但是这道题很特殊，它的查询的是正方形，因此并不需要二维倍增。所以就砍下了一维。下面会给出常规二维RMQ与特殊二维RMQ。空间复杂度： $O(n^{2}logk)$ 。时间复杂度： $O(n^{2}logk)$ 。 DP据说可以用单调队列维护。我太蒻了，并不会。。。。。 代码二维RMQ123456789101112131415161718192021222324252627282930313233343536const int kmax_num = 1e3 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n, m, k;int rmq_max[kmax_num][kmax_num][11][11], rmq_min[kmax_num][kmax_num][11][11];inline void Init() &#123; for(REG int i = 1; (1 &lt;&lt; i) &lt;= n; ++i) for(REG int h = 1; (1 &lt;&lt; h) &lt;= m; ++h) &#123; if(!i &amp;&amp; !h) continue; else &#123; for(REG int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; ++row) for(REG int col = 1; col + (1 &lt;&lt; h) - 1 &lt;= m; ++col) if(i) rmq_max[row][col][i][h] = std::max(rmq_max[row][col][i - 1][h], rmq_max[row + (1 &lt;&lt; (i - 1))][col][i - 1][h]), rmq_min[row][col][i][h] = std::min(rmq_min[row][col][i - 1][h], rmq_min[row + (1 &lt;&lt; (i - 1))][col][i - 1][h]); else rmq_max[row][col][i][h] = std::max(rmq_max[row][col][i][h - 1], rmq_max[row][col + (1 &lt;&lt; (h - 1))][i][h - 1]), rmq_min[row][col][i][h] = std::min(rmq_min[row][col][i][h - 1], rmq_min[row][col + (1 &lt;&lt; (h - 1))][i][h - 1]); &#125; &#125; return ;&#125;inline int Query(REG int ax, REG int ay, REG int bx, REG int by) &#123; REG int t1 = (int) log2(bx - ax + 1); REG int t2 = (int) log2(by - ay + 1); REG int m1 = rmq_max[ax][ay][t1][t2]; REG int m2 = rmq_max[bx - (1 &lt;&lt; t1) + 1][ay][t1][t2]; REG int m3 = rmq_max[ax][by - (1 &lt;&lt; t2) + 1][t1][t2]; REG int m4 = rmq_max[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t2) + 1][t1][t2]; REG int m5 = rmq_min[ax][ay][t1][t2]; REG int m6 = rmq_min[bx - (1 &lt;&lt; t1) + 1][ay][t1][t2]; REG int m7 = rmq_min[ax][by - (1 &lt;&lt; t2) + 1][t1][t2]; REG int m8 = rmq_min[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t2) + 1][t1][t2]; return std::max(std::max(m1, m2), std::max(m3, m4)) - std::min(std::min(m5, m6), std::min(m7, m8));&#125; 二维RMQ-UDP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e3 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n, m, k;int rmq_max[kmax_num][kmax_num][11], rmq_min[kmax_num][kmax_num][11];inline void Init() &#123; for(REG int i = 1; (1 &lt;&lt; i) &lt;= k; ++i) &#123; for(REG int row = 1; row + (1 &lt;&lt; i) - 1 &lt;= n; ++row) for(REG int col = 1; col + (1 &lt;&lt; i) - 1 &lt;= m; ++col) rmq_max[row][col][i] = std::max(std::max(rmq_max[row][col][i - 1], rmq_max[row + (1 &lt;&lt; (i - 1))][col][i - 1]), std::max(rmq_max[row][col + (1 &lt;&lt; (i - 1))][i - 1], rmq_max[row + (1 &lt;&lt; (i - 1))][col + (1 &lt;&lt; (i - 1))][i - 1])), rmq_min[row][col][i] = std::min(std::min(rmq_min[row][col][i - 1], rmq_min[row + (1 &lt;&lt; (i - 1))][col][i - 1]), std::min(rmq_min[row][col + (1 &lt;&lt; (i - 1))][i - 1], rmq_min[row + (1 &lt;&lt; (i - 1))][col + (1 &lt;&lt; (i - 1))][i - 1])); &#125; return ;&#125;inline int Query(REG int ax, REG int ay, REG int bx, REG int by) &#123; REG int t1 = (int) log2(bx - ax + 1);// REG int t1 = (int) log2(k + 1); REG int m1 = rmq_max[ax][ay][t1]; REG int m2 = rmq_max[bx - (1 &lt;&lt; t1) + 1][ay][t1]; REG int m3 = rmq_max[ax][by - (1 &lt;&lt; t1) + 1][t1]; REG int m4 = rmq_max[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t1) + 1][t1]; REG int m5 = rmq_min[ax][ay][t1]; REG int m6 = rmq_min[bx - (1 &lt;&lt; t1) + 1][ay][t1]; REG int m7 = rmq_min[ax][by - (1 &lt;&lt; t1) + 1][t1]; REG int m8 = rmq_min[bx - (1 &lt;&lt; t1) + 1][by - (1 &lt;&lt; t1) + 1][t1]; return std::max(std::max(m1, m2), std::max(m3, m4)) - std::min(std::min(m5, m6), std::min(m7, m8));&#125;int main() &#123; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; For(i,1,n) For(h,1,m) std::cin &gt;&gt; rmq_max[i][h][0], rmq_min[i][h][0] = rmq_max[i][h][0]; Init(); REG int ans = 0x7fffffff; for(REG int i = 1; i + k - 1 &lt;= n; ++i) for(REG int h = 1; h + k - 1 &lt;= m; ++h) ans = std::min(ans, Query(i, h, i + k - 1, h + k - 1)); printf("%d\n", ans); return 0;&#125; 杂项 这里的二维 $RMQ$ 要是 $(n \ == \ 0 \ || \ m \ == \ 0)$ 就是一个一维 $RMQ$ 。]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>二维RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003] 消防局的设立]]></title>
    <url>%2F%2FHNOI2003-%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[题目链接[HNOI2003]消防局的设立 题意简述给出一棵节点数为 $n \ (n &lt;= 1000)$ 的树，每条边长度为 $1$ 。 一次操作作用于一个节点，并将距此节点 $dist &lt;= 2$ 的节点染色，求将整棵树染上颜色的最小次数。 思路暴力首先考虑暴力，也就是暴力枚举。时间复杂度： $O(n^{2})$ 。由于数据太水，暴力随便打吧。 贪心一开始我是想到节点要尽可能向中间靠拢，染色少浪费，可是并不容易做到。从上向下？没思路。（一开始没想到）但从下向上就好想多了。记录 $BFS$ 序，也就是深度。从最底层找起，当它没被染色时，给它的爷爷（雾）染色 $(depth &lt;= 2)$ ，这样能保证高效利用。为什么不用 $DFS$ 记录呢？ 效率不及 $BFS$ 。 记录深度还要排序，而 $BFS$ 记录只需要一个栈。时间复杂度： $O(n)$ （大概吧）。 树形DP我太蒻了，并不会。。。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 2e3 + 10, kmax_int = 2147483647, kmod = 1e9+7;#define pii std::pair&lt;int, int&gt;#define ppiii std::pair&lt;pii, int&gt;#define mp std::make_pairint n;pii e[kmax_num];int head[kmax_num], cnt;int f[kmax_num];inline void AddEdge(REG int u, REG int v) &#123; e[++cnt] = mp(v, head[u]); head[u] = cnt; e[++cnt] = mp(u, head[v]); head[v] = cnt; return ;&#125;std::queue&lt;int&gt; q;std::stack&lt;int&gt; s;inline void BFS() &#123; q.push(1), s.push(1); while(!q.empty()) &#123; REG int u = q.front(); q.pop(); for(REG int i = head[u]; i; i = e[i].second) if(e[i].first != f[u]) q.push(e[i].first), s.push(e[i].first); &#125; return ;&#125;bool vis[kmax_num];std::queue&lt;pii&gt; mq;inline void Mark(REG int u, REG int dep) &#123; mq.push(mp(u, 0)); while(!mq.empty()) &#123; REG pii u = mq.front(); mq.pop(); for(REG int i = head[u.first]; i; i = e[i].second) &#123; vis[e[i].first] = 1; if(u.second &lt; 1) mq.push(mp(e[i].first, u.second + 1)); &#125; &#125; return ;&#125;int main() &#123; std::cin &gt;&gt; n; FOR(i,1,n) std::cin &gt;&gt; f[i + 1], AddEdge(f[i + 1], i + 1); BFS(); REG int ans = 0; while(!s.empty()) &#123; REG int u = s.top(); s.pop(); if(!vis[u]) vis[u] = true, Mark(f[f[u]], 0), ++ans; &#125; printf("%d\n", ans); return 0;&#125; 杂项 这里用了 $std::pair$ 实现，$std::pair$ 大法好！]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF962D Merge Equals]]></title>
    <url>%2F%2FCF962D-Merge-Equals%2F</url>
    <content type="text"><![CDATA[题目链接CF962D Merge Equals 题意简述给出一个长度为 $n \ (2&lt;= n &lt;= 150000)$ 的数组， 数组内元素 $a{i} \ (1 &lt;= a{i} &lt;= 1e9)$ 。 每次操作将数组内两个相同的最小的最靠左的元素取出，并将左边的合并到右边，直到不能操作为止，输出最后的数组。 例：$[1, 1, 3, 1, 1]~\rightarrow~[2, 3, 1, 1]~\rightarrow~[2, 3, 2]~\rightarrow~[3, 4]$ 思路暴力首先考虑暴力，也就是暴力查找。时间复杂度： $O(n^{2})$ 。 正解正解应该挺容易想到的，用堆维护数值和位置，每次取出两个，不相同就删了第一个，否则合并。时间复杂度： $O(n \ log(n))$ 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e6 + 10, kmax_int = 2147483647, kmod = 1e9+7;#define pli std::pair&lt;long long, int&gt;#define mp std::make_pairint n;long long f[kmax_num];std::set&lt;pli&gt; set;int main() &#123; std::cin &gt;&gt; n; FOR(i,0,n) std::cin &gt;&gt; f[i], set.insert(mp(f[i], i)); REG pli t1, t2; while(!set.empty()) &#123; t1 = *set.begin(), t2 = *(++set.begin()); if(t1.first != t2.first) &#123; set.erase(set.begin()); &#125; else &#123; set.insert(mp(t1.first &lt;&lt; 1, t2.second)); f[t1.second] = 0; f[t2.second] = t1.first &lt;&lt; 1; set.erase(set.begin()); set.erase(set.begin()); &#125; &#125; REG int ans = 0; FOR(i,0,n) if(f[i]) ++ans; printf("%d\n", ans); FOR(i,0,n) if(f[i]) printf("%lld ", f[i]); printf("\n"); return 0;&#125; 杂项 这里用 $std::set$ 实现，$std::set$ 大法好！ 这里还用了 $std::pair$ 实现，$std::pair$ 大法好！ 这道题在洛谷上居然是紫题！！还不去水一发吗2333]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2009] 生日礼物]]></title>
    <url>%2F%2FSCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[题目链接[SCOI2009]生日礼物 题意简述有一条纸带上挂着 $n \ (n &lt;= 1000000)$ 个小球，小球有 $k \ (k &lt;= 60)$ 种颜色。 找出一个最小的包含所有颜色的区间。 思路单调队列使一个队列中一直保持有所有颜色，不断向右移动若末尾小球的颜色出现次数 $ &gt; 1$ ，将其弹出，直到末尾小球的颜色出现次数 $ = 1$ 。时间复杂度： $O(n)$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 1e6 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n, k;#define pii std::pair&lt;int, int&gt;#define mp std::make_pairpii point[kmax_num];int col[61];std::deque&lt;pii&gt; queue;inline bool Check() &#123; For(i,1,k) if(!col[i]) return 1; return 0;&#125;int main() &#123; std::cin &gt;&gt; n &gt;&gt; k; REG int sum, pos, cnt = -1; For(i,1,k) &#123; std::cin &gt;&gt; sum; FOR(h,0,sum) &#123; std::cin &gt;&gt; pos; point[++cnt] = mp(pos, i); &#125; &#125; std::sort(point, point + n); cnt = 0; while(Check()) &#123; queue.push_front(point[cnt]); ++col[point[cnt].second]; ++cnt; &#125; REG int ans = 0x7fffffff; while(cnt &lt; n) &#123; ans = std::min(ans, queue.front().first - queue.back().first); queue.push_front(point[cnt]); ++col[point[cnt].second]; while(col[queue.back().second] &gt; 1) --col[queue.back().second], queue.pop_back(); ++cnt; &#125; ans = std::min(ans, queue.front().first - queue.back().first); printf("%d\n", ans); return 0;&#125; 杂项 这里用了 $std::pair$ 实现，$std::pair$ 大法好！]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2011] 糖果]]></title>
    <url>%2F%2FSCOI2011-%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[题目链接[SCOI2011]糖果 题意简述有 $n$ 个点， $k$ 种关系。 有 $5$ 种关系类型。 W_{A} == W_{B} W_{A} < W_{B} W_{A} >= W_{B} W_{A} > W_{B} W_{A} = 0 \ and \ b - a >= 0) \rightarrow (edge_{b \rightarrow a} = 0, edge_{a \rightarrow b} = 0) W_{A} < W_{B} \rightarrow (b - a > 0 \rightarrow b - a >= 1) \rightarrow (edge_{a \rightarrow b} = 1) W_{A} >= W_{B} \rightarrow (a - b >= 0) \rightarrow (edge_{b \rightarrow a} = 0) W_{A} > W_{B} \rightarrow (a - b > 0 \rightarrow a - b >= 1) \rightarrow (edge_{b \rightarrow a} = 1) W_{A} = 0) \rightarrow (edge_{a \rightarrow b} = 0) 由于每个点都权值至少为 $1$ ，所以 $edge_{S \rightarrow i} = 1$。跑最长路即可。时间复杂度： $O(qk)$ 。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 3e5 + 10, kmax_int = 0x3f3f3f3f, kmod = 1e9+7;#define foe(x, y) for(REG int (x) = head[(y)]; (x); (x) = edges[i].l)int n, m;struct SPFA &#123; struct Edge &#123; int v, d, l; &#125; edges[kmax_num]; int head[(int)1e5 + 10], cnt; int dist[(int)1e5 + 10]; int sum[(int)1e5 + 10]; bool vis[(int)1e5 + 10]; inline void AddEdge(REG int u, REG int v, REG int d) &#123; edges[++cnt] = (Edge) &#123;v, d, head[u]&#125;; head[u] = cnt; return ; &#125; inline bool Solve(REG int num) &#123; std::queue&lt;int&gt; queue; queue.push(num); memset(vis, 0, sizeof(vis)); vis[num] = 1; std::fill(dist, dist + n + 1, -1e9); dist[num] = 0; REG int u; while(!queue.empty()) &#123; u = queue.front(); queue.pop(); vis[u] = 0; if(sum[u] == n + 1) &#123; puts("-1"); return false; &#125; foe(i,u) &#123; if(dist[edges[i].v] &lt; dist[u] + edges[i].d) &#123; dist[edges[i].v] = dist[u] + edges[i].d; if(!vis[edges[i].v]) &#123; queue.push(edges[i].v); vis[edges[i].v] = 1; ++sum[edges[i].v]; &#125; &#125; &#125; &#125; return true; &#125;&#125; spfa;int main() &#123; std::cin &gt;&gt; n &gt;&gt; m; REG int cmd, a, b; FOR(i,0,m) &#123; std::cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b; if(cmd == 1) spfa.AddEdge(a, b, 0), spfa.AddEdge(b, a, 0); else if(cmd == 2) spfa.AddEdge(a, b, 1); else if(cmd == 3) spfa.AddEdge(b, a, 0); else if(cmd == 4) spfa.AddEdge(b, a, 1); else if(cmd == 5) spfa.AddEdge(a, b, 0); if(cmd == 2 || cmd == 4) if(a == b) &#123; puts("-1"); return 0; &#125; &#125;// For(i,1,n) spfa.AddEdge(0, i, 1); for(REG int i = n; i ; --i) spfa.AddEdge(0, i, 1); if(!spfa.Solve(0)) return 0; REG long long ans = 0; For(i,1,n) ans += spfa.dist[i]; printf("%lld\n", ans); return 0;&#125; 杂项 最后面向源点加边时不知道为什么正着加会被卡掉 $QAQ$ ，所以就倒着加了。]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2005] 阶梯教室设备利用]]></title>
    <url>%2F%2FSDOI2005-%E9%98%B6%E6%A2%AF%E6%95%99%E5%AE%A4%E8%AE%BE%E5%A4%87%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[题目链接[SDOI2005] 阶梯教室设备利用 题意简述有 $n$ 个演讲，一次只能举行 $1$ 个。 某一演讲结束的瞬间可以立即开始另一个演讲。 计算最大的可能演讲总时间。 思路DP转移方程显而易见（设开始为 $l$ ，结束为 $r$ ）： f[r] = std::max(f[r], \ f[i] + r - l) \ (i \in [0, l])问题是不好转移啊2333。考虑用线段树维护最大值。单点更新，区间求最大值即可。时间复杂度： $O(nlogn)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define REG register#define IN inline#define For(x,y,z) for (REG int (x) = (y); (x) &lt;= (z); ++(x))#define FOR(x,y,z) for (REG int (x) = (y); (x) &lt; (z); ++(x))const int kmax_num = 3e4 + 10, kmax_int = 2147483647, kmod = 1e9+7;int n;int f[kmax_num];std::pair&lt;int, int&gt; t[kmax_num];struct SegmentTree &#123; int val[kmax_num &lt;&lt; 2]; #define lson (root &lt;&lt; 1) #define rson (root &lt;&lt; 1) | 1 inline void PushUp(REG int root) &#123; val[root] = std::max(val[lson], val[rson]); return ; &#125; inline void Update(REG int root, REG int begin, REG int end, REG int udp_begin, REG int udp_end, REG int num) &#123; if(udp_begin &lt;= begin &amp;&amp; udp_end &gt;= end) &#123; val[root] = std::max(val[root], num); return; &#125; else &#123; REG int mid = (begin + end) &gt;&gt; 1; if(udp_begin &lt;= mid) Update(lson, begin, mid, udp_begin, udp_end, num); if(udp_end &gt; mid) Update(rson, mid + 1, end, udp_begin, udp_end, num); PushUp(root); return ; &#125; &#125; inline int Query(REG int root, REG int begin, REG int end, REG int que_begin, REG int que_end) &#123; if(que_begin &lt;= begin &amp;&amp; que_end &gt;= end) &#123; return val[root]; &#125; else &#123; REG int mid = (begin + end) &gt;&gt; 1, ans = -0x7fffffff; if(que_begin &lt;= mid) ans = std::max(ans, Query(lson, begin, mid, que_begin, que_end)); if(que_end &gt; mid) ans = std::max(ans, Query(rson, mid + 1, end, que_begin, que_end)); return ans; &#125; &#125; #undef lson #undef rson&#125; segment_tree;int main() &#123; std::cin &gt;&gt; n; REG int l, r; FOR(i,0,n) std::cin &gt;&gt; l &gt;&gt; r, t[i].first = l, t[i].second = r; sort(t, t + n); FOR(i,0,n) &#123; l = t[i].first, r= t[i].second; f[r] = std::max(f[r], segment_tree.Query(1, 0, kmax_num - 1, 0, l) + r - l); segment_tree.Update(1, 0, kmax_num - 1, r, r, f[r]); &#125; printf("%d\n", segment_tree.Query(1, 0, kmax_num - 1, 0, kmax_num - 1)); return 0;&#125; 杂项 这里记录开始和结束用了 $std::pair$ 实现，$std::pair$ 大法好！ 根本不需要 $std::pair$ 好不好！可以直接用两个数组实现！]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
